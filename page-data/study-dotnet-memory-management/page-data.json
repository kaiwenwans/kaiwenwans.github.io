{"componentChunkName":"component---src-templates-blog-post-js","path":"/study-dotnet-memory-management/","result":{"data":{"site":{"siteMetadata":{"title":"kevin wang's blog"}},"markdownRemark":{"id":"ddf6ff32-a6d0-5072-8c54-90273723b6e7","excerpt":"這一季聽了許多同事在記憶體管理的一些討論， 決定花一些時間來讀官方文件以及動手實作看看。 在研究記憶體管理之前要先有相關監測工具， 我使用 .Net 內建的工具來做監測。 先執行一個簡單的 Hello world 並透過以下指令取得 process id: 然後找到要監測的 pid…","html":"<p>這一季聽了許多同事在記憶體管理的一些討論，<br>\n決定花一些時間來讀官方文件以及動手實作看看。</p>\n<p>在研究記憶體管理之前要先有相關監測工具，<br>\n我使用 .Net 內建的工具來做監測。</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">dotnet tool install --global dotnet-trace\ndotnet tool install --global dotnet-counters</code></pre></div>\n<p>先執行一個簡單的 Hello world</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">    class Program\n    {\n        static void Main(string[] args)\n        {\n            Console.WriteLine(&quot;Hello World!&quot;);\n            Console.ReadKey();\n        }\n    }</code></pre></div>\n<p>並透過以下指令取得 process id:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">dotnet-trace <span class=\"token function\">ps</span></code></pre></div>\n<p>然後找到要監測的 pid</p>\n<p>接下來執行</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">dotnet-counters monitor --refresh-interval <span class=\"token number\">1</span> -p <span class=\"token punctuation\">{</span>pid<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[System.Runtime]\n    % Time in GC since last GC (%)                         0\n    Allocation Rate / 1 sec (B)                        8,168\n    CPU Usage (%)                                          0\n    Exception Count / 1 sec                                0\n    GC Heap Size (MB)                                      0\n    Gen 0 GC Count / 60 sec                                0\n    Gen 0 Size (B)                                         0\n    Gen 1 GC Count / 60 sec                                0\n    Gen 1 Size (B)                                         0\n    Gen 2 GC Count / 60 sec                                0\n    Gen 2 Size (B)                                         0\n    LOH Size (B)                                           0\n    Monitor Lock Contention Count / 1 sec                  0\n    Number of Active Timers                                0\n    Number of Assemblies Loaded                            7\n    ThreadPool Completed Work Item Count / 1 sec           0\n    ThreadPool Queue Length                                0\n    ThreadPool Thread Count                                2\n    Working Set (MB)                                      20</code></pre></div>\n<p>接下來要多產生一些物件</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tConsole.WriteLine(&quot;press any key to start&quot;);\n\t\t\tConsole.ReadKey();\n\t\t\tfor (var i = 1; i &lt; 10 * 60; i++)\n\t\t\t{\n\t\t\t\tvar array = new byte[500000];\n\t\t\t\tvar random = new Random();\n\t\t\t\trandom.NextBytes(array);\n\t\t\t\tThread.Sleep(100);\n\t\t\t}\n\t\t\tConsole.WriteLine(&quot;press any key exit...&quot;);\n\t\t\tConsole.ReadKey();\n\t\t}\n\t}</code></pre></div>\n<p>執行中</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[System.Runtime]\n    % Time in GC since last GC (%)                         0\n    Allocation Rate / 1 sec (B)                    5,008,128\n    CPU Usage (%)                                          0\n    Exception Count / 1 sec                                0\n    GC Heap Size (MB)                                      2\n    Gen 0 GC Count / 60 sec                              120\n    Gen 0 Size (B)                                        24\n    Gen 1 GC Count / 60 sec                              120\n    Gen 1 Size (B)                                     5,952\n    Gen 2 GC Count / 60 sec                              120\n    Gen 2 Size (B)                                   239,456\n    LOH Size (B)                                   4,020,088\n    Monitor Lock Contention Count / 1 sec                  0\n    Number of Active Timers                                0\n    Number of Assemblies Loaded                            8\n    ThreadPool Completed Work Item Count / 1 sec           0\n    ThreadPool Queue Length                                0\n    ThreadPool Thread Count                                2\n    Working Set (MB)                                      24</code></pre></div>\n<p>執行結束</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[System.Runtime]\n    % Time in GC since last GC (%)                         0\n    Allocation Rate / 1 sec (B)                        8,168\n    CPU Usage (%)                                          0\n    Exception Count / 1 sec                                0\n    GC Heap Size (MB)                                      2\n    Gen 0 GC Count / 60 sec                                0\n    Gen 0 Size (B)                                        24\n    Gen 1 GC Count / 60 sec                                0\n    Gen 1 Size (B)                                   117,360\n    Gen 2 GC Count / 60 sec                                0\n    Gen 2 Size (B)                                   117,704\n    LOH Size (B)                                   3,520,032\n    Monitor Lock Contention Count / 1 sec                  0\n    Number of Active Timers                                0\n    Number of Assemblies Loaded                            8\n    ThreadPool Completed Work Item Count / 1 sec           0\n    ThreadPool Queue Length                                0\n    ThreadPool Thread Count                                0\n    Working Set (MB)                                      24</code></pre></div>\n<p>以上資訊有幾個名詞</p>\n<p>其中</p>\n<p>Allocation Rate / 1 sec (B) 約為 5,000,000\n(程式碼是每100毫秒 new byte[500000]</p>\n<p>大型物件堆積(LOH)占用非常多的原因是因為當物件要求超過 85,000 B的時候，<br>\nruntime 會一律將物件放在 LOH 上，<br>\n而小於 85,000 B 的物件會放在(小型物件堆積) SOH 上。</p>\n<h2>物件在記憶體中會放在以下幾個層代</h2>\n<ul>\n<li>層代 0(Gen 0)</li>\n<li>層代 1(Gen 1)</li>\n<li>層代 2(Gen 2)</li>\n</ul>\n<p>占用記憶體小的物件會在 Gen 0 結束，\n留存比較久的物件會提升到 Gen 1 或 Gen 2，\n提升的條件為 GC 發生後沒被回收的物件就會被提升，\n而大型物件會一律在 Gen 2 中。</p>\n<h2>GC通常發生在</h2>\n<ol>\n<li>Gen 0 達到回收閥值</li>\n<li>LOH 達到回收閥值</li>\n<li>系統記憶體不足(由作業系統通知)</li>\n<li>呼叫 GC.Collect() 後強制執行<br>\n(不是每種 runtime 都是這樣實作的，如Java的實作是只通知 GC ，系統不一定會馬上執行，也可能忽略 GC 請求)</li>\n</ol>\n<h2>GC有兩種方式</h2>\n<ol>\n<li>工作站垃圾收集(Workstation garbage collection)\n在只有一個處理器的的機器上會強制使用這種方式，\nGC執行緒會與其他執行緒搶CPU時間</li>\n<li>伺服器垃圾收集(Server garbage collection)\n每個處理器上都會有一條專門GC執行緒，<br>\n由於有多個 GC 執行緒，<br>\n所以 GC 速度會比工作站垃圾收集快，\n但是如果有多個程式在同一台機器上使用伺服器垃圾收集時會互搶CPU時間，<br>\n所以會建議不要同時開伺服器垃圾回收，<br>\n甚至在上百個程式在同一台機器上運行時，<br>\n建議切換為工作站垃圾收集避免大量的 context switch。  </li>\n</ol>\n<h2>前景GC與背景GC</h2>\n<p>GC 也分為</p>\n<ol>\n<li>\n<p>背景垃圾收集(background GC)</p>\n<blockquote>\n<p>在背景垃圾收集發生時所有託管的執行緒會盡可能的繼續執行</p>\n</blockquote>\n</li>\n<li>\n<p>前景垃圾收集(foreground GC)</p>\n<blockquote>\n<p>在前景垃圾收集發生時所有託管的執行緒都必須暫停執行</p>\n</blockquote>\n</li>\n</ol>\n<h2>不同Gen有不同的回收期間</h2>\n<p>Gen 1 GC 發生時，會同時對 Gen 0 與 Gen 1 做記憶體回收，<br>\nGen 2 GC 發生時，則會同時對 Gen 0、Gen 1 與 Gen 2 做記憶體回收，\n所以Gen 2 GC又稱為完整GC。  </p>\n<h2>以下是一塊記憶體配置的示例</h2>\n<h3>SOH Allocations and GC</h3>\n<ol>\n<li>\n<p>GC前</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">----------------------------------------------------\n|Obj1(使用中) |Obj2(未使用)|Obj3(使用中)|Obj4(未使用)|\n----------------------------------------------------\n|            |            |           |\nGen 0        Gen 0        Gen 0       Gen 0</code></pre></div>\n</li>\n<li>\n<p>開始GC</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">----------------------------------------------------\n|Obj1(使用中) |            |Obj3(使用中)|           |\n----------------------------------------------------</code></pre></div>\n</li>\n<li>\n<p>壓縮</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">----------------------------------------------------\n|Obj1(使用中) |Obj3(使用中)|                        |\n----------------------------------------------------\n|\nGen 1</code></pre></div>\n<p>此時Obj1 Obj3提升到Gen 1</p>\n</li>\n</ol>\n<h3>LOH Allocations and GC</h3>\n<ol>\n<li>\n<p>GC前</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">----------------------------------------------------\n|Obj1(使用中) |Obj2(未使用)|Obj3(使用中)|Obj4(未使用)|\n----------------------------------------------------\n|            |            |           |\nGen 2        Gen 2        Gen 2       Gen 2</code></pre></div>\n</li>\n<li>\n<p>GC</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">----------------------------------------------------\n|Obj1(使用中) |            |Obj3(使用中)|           |\n----------------------------------------------------\n|                         |\nGen 2                     Gen 2</code></pre></div>\n</li>\n</ol>\n<p>LOH 的記憶體區塊通常不會壓縮，<br>\n因為大型物件的搬移成本較高，<br>\n在較新的 runtime 可以透過設定，<br>\nGCSettings.LargeObjectHeapCompactionMode<br>\n決定是否要做 LOH 壓縮(*7)<br>\n(文件有提到目前不會自動壓縮 LOH 但未來 .Net 不排除會自動壓縮 LOH )  </p>\n<h3>記憶體使用不當對效能的影響</h3>\n<ol>\n<li>頻繁 GC 導致執行緒被暫停吞吐量降低  </li>\n<li>記憶體碎片過多導致頻繁壓縮甚至因無法配置記憶體導致記憶體不足  </li>\n</ol>\n<h3>記憶體使用上的一些優化技巧</h3>\n<ol>\n<li>在預先知道集合大小時直接配置剛好的大小避免自動配置導致配置多餘的記憶體。  </li>\n<li>在集合(如列表)可重用的情形下直接透過 static 宣告直接重用。<br>\n(通常在不平行執行的 Job 等只有一條執行緒存取的情境較常見)  </li>\n<li>若是資料物件傳遞的情境可以考慮定出介面並實作，<br>\n使物件傳遞時不須因為要轉換成小物件而需再建立一個小物件並重新賦值。  </li>\n</ol>\n<p>如</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">\t\tpublic interface IAccountInfo\n\t\t{\n\t\t\tstring AccountId { get; set; }\n\t\t\tstring Password { get; set; }\n\t\t\tstring Name { get; set; }\n\t\t\tint Gender { get; set; }\n\t\t\tstring FirstName { get; set; }\n\t\t\tstring LastName { get; set; }\n\t\t}\n\n\t\tpublic class AccountInfo : IAccountInfo, ISmallAccountInfo\n\t\t{\n\t\t\tpublic string AccountId { get; set; }\n\t\t\tpublic string Password { get; set; }\n\t\t\tpublic string Name { get; set; }\n\t\t\tpublic int Gender { get; set; }\n\t\t\tpublic string FirstName { get; set; }\n\t\t\tpublic string LastName { get; set; }\n\t\t\tpublic string FullName { get =&gt; FirstName + LastName; }\n\t\t}\n\n\t\tpublic interface ISmallAccountInfo\n\t\t{\n\t\t\tstring AccountId { get; }\n\t\t\tstring Password { get; }\n\t\t\tstring FullName { get; }\n\t\t}\n\n\t\tpublic class SmallAccountInfo : ISmallAccountInfo\n\t\t{\n\t\t\tpublic string AccountId { get; }\n\t\t\tpublic string Password { get; }\n\t\t\tpublic string FullName { get; }\n\t\t}</code></pre></div>\n<p>在取得 AccountInfo 物件後，<br>\n若需要呼叫一個方法而此方法需要 SmallAccountInfo 資料物件，<br>\n就可以考慮透過這樣的技巧省去新配置物件以及賦值。</p>\n<ol start=\"4\">\n<li>部分無狀態物件可考慮用 Singleton，<br>\n但建議透過DI容器來使用 Singleton。  </li>\n<li>實作 Object Pool 將部分常常重複建立的物件都透過Pool來取得避免不斷重配置記憶體後再被回收。(手機應用開發上很常見)  </li>\n<li>使用 .Net 提供的 Span&#x3C;T> 和 Memory&#x3C;T> API操作記憶體</li>\n</ol>\n<p>ref:</p>\n<ol>\n<li><a href=\"https://docs.microsoft.com/zh-tw/dotnet/core/diagnostics/dotnet-trace\">MSDN dotnet-追蹤效能分析公用程式</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-tw/dotnet/core/diagnostics/dotnet-counters\">MSDN (dotnet) 的計數器調查效能計數器</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-tw/aspnet/core/performance/memory?view=aspnetcore-3.1\">MSDN ASP.NET Core 中的記憶體管理和垃圾收集 (GC)</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-tw/dotnet/core/diagnostics/debug-memory-leak\">MSDN 在 .NET Core 中偵測記憶體流失</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-tw/dotnet/standard/garbage-collection/background-gc\">MSDN 背景垃圾收集</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-tw/dotnet/api/system.gc.collect?view=netcore-3.1\">MSDN GC.Collect 方法</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-tw/dotnet/api/system.runtime.gcsettings.largeobjectheapcompactionmode?view=netcore-3.1\">MSDN GCSettings.LargeObjectHeapCompactionMode 屬性</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-tw/dotnet/standard/garbage-collection/workstation-server-gc\">MSDN 工作站和伺服器記憶體回收</a></li>\n</ol>","frontmatter":{"title":".Net 記憶體管理的一些 study","date":"June 26, 2020","description":"study .net memory management"}}},"pageContext":{"slug":"/study-dotnet-memory-management/","previous":null,"next":{"fields":{"slug":"/study-dotnet-span-api/"},"frontmatter":{"title":".Net Span<T> API and Memory<T> API Study"}}}},"staticQueryHashes":["3000541721","3274528899"]}